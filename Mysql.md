# Mysql
## 索引
### 索引原理
数据库如何查找我们所需的数据呢？如果没有索引，会进行全表扫描，这样如果数据表数据很大，会有很多次I/O操作，磁盘I/O会大大降低性能。为减少I/O操作引入了索引，底层使用B+树，将索引列加载到内存，数据全部在叶子节点，可以大大减少I/O操作，并且可以很快定位到我们所需要的数据，只需要很少的I/O操作将我们所需数据加载到内存放回就行，不需要将全表内容加载到内存。  
<div align="center">
<img src=https://user-images.githubusercontent.com/34670345/175211944-c773dcc9-cb24-426c-99e7-482cec78e3cf.jpg height=350px />
</div>

### 分类
* 按照存储结构分类
1. 聚集索引：叶子节点存储了数据，不是指向数据的指针。
2. 非聚集索引：叶子阶段存储了指向数据的指针。
* 按照应用角度分类
1. 唯一索引：可以确保被索引的字段不存在重复值。
2. 单列索引，在单个字段上创建的索引。
3. 多列索引，在多个字段组合创建索引，也称为复合索引。

### 索引维护
1. 索引创建
```text
creat [unique] index index_name on table_name(coll [ASC|DESC], ...);
```
ASC: 升序，DESC: 降序，unique:唯一索引。我们创建主键和唯一约束的时候，数据库会自动创建相应的索引。  
2. 查看索引
```text
show indexes from table_name
```
3. 删除索引
```
drop index index_name
```
4. 查看执行计划
```
explain + sql 语句
```
## 查询性能优化
### 创建合适的索引
1. 基于经常出现在where条件中的字段建立索引，可以避免全表扫描
2. 基于多表连接字段建索引，可以提高连接查询的速度
3. 将group by分组字段加入索引，可以利用索引实现分组
4. 将order by排序字段加入索引，可以避免额外的排序操作。
### 避免索引失效
1. 在查询条件中对索引字段进行运算，或者使用函数会导致索引失效
2. 使用like模糊查询，通配符出现在左侧会导致索引失效（最左匹配原则）
### 优化返回的数据
1. 只查询需要的列，不要用select *
2. 返回必要的行，使用limmit限制行数
3. 使用缓存，缓存重复数据。减少数据库压力
### 重构查询方式
1. 切分大查询
* 一个大查询一次执行的话，锁住很多数据表，阻塞很多小的查询。
2. 分解大连接查询
将一个大连接查询分解成对每个表的单表查询，然后在应用程序中进行关联，这样做的好处有：
* 让缓存更高效，如果是大连接查询，缓存的数据会因一张表的内容改变而失效，但是，单表查询数据，缓存数据粒度很细。数据有效性更高。
* 可以减少锁的竞争。
* 在应用层进行连接，可以更容易对数据库进行拆分。

### 分表
1. 水平切分，可以使用id进行hash,将不同数据分布在集群的不同节点上，从而减轻对单个数据库查询的压力。
2. 垂直切分，将一张表按照列切分为多张表，通常是按照列的关系密集关系进行切分，例如将电商数据表切分为商品表和用户表。

### Mysql数据库事务的基本特征？靠什么保证？
* ACID: 分别是原子性，一致性，隔离性，持久性。
* 原子性: 是指一个事务的所有操作要么都执行成功，要么都执行失败。undo日志记录了需要回滚的事务，通过undo日志，将执行失败的事务回滚，保证原子性。
* 一致性: 数据库从一个状态转移到另一个状态，一般由代码层面实现。
* 隔离性: 事务提交前，对其他事务的不可见性。MVCC实现。
* 持久性: 事务一旦提交，数据会持久保存在数据库。通过内存+redo日志，修改数据，在内存和redo日志中记录该操作，事务提交会，将redo日志刷盘，持久保存。

### 数据库的隔离性有那些？
* read-uncommit: 读未提交，有脏读，不可重复读，幻读问题
* read-commit: 读已提交，有不可重复读，幻读问题
* reapeatable-commit: 可重复读，有幻读问题。
* serializable: 序列化，

### 脏读，不可重复读，幻读？
* 脏读: A，B两个事务，B事务读取到A事务修改未提交的数据。造成数据的错误。
* 不可重复读: A事务多次读取数据过程中，B事务updata了数据，使得多次事务读取的数据不一致。
* 幻读: A事务查询数据条数，B事务执行插入或删除操作，使得A事务查询数据不一致。

### 什么是MVCC ?
* 多版本并发控制，每个数据表都有两个隐藏字段，创建时间版本号，过期时间版本号，每开启一个事务，版本号+1。
* 查询时，查询创建版本号<=当前版本号&&（过期版本号>当前版本号||过期版本号为空）的数据。
* 这样保证了，查询数据时开启事务之前的数据或者是本身事务修改后的数据。

### 如何定位慢查询？
* 在调试阶段，开启mysql中慢查询功能，将慢查询的sql语句输出到日志文件中，日志文件中有对应的查询时间以及查询语句
* 可以快速定位到具体的问题。
### 如何解决慢查询？
* 使用mysql的explain 查询语句的执行信息，其中有possible_key 字段表明可能使用到的所有，key字段表明使用的所有。
* type: const:更具主键索引查询，eq_ref: 唯一索引查询，ref:索引查询，range:范围查询，index:索引树查询，all:全盘索引。
* extra: 优化建议，using index condition 的时候，出现回表
* 首先依据key key_len判断sql是否走索引，
* 通过type判断sql是否有优化空间，是否存在索引扫描，和全盘查询
* 通过extra判断，判断是否出现了回表，如果出现，可以添加索引。

###  什么是索引？
* 索引是帮助mysql快速检索数据的数据结构，Innodb引擎使用B+树结构
* 通过索引可以避免全局扫描，降低IO次数提高销量
* 通过索引，可以对数据排序，减低cpu消耗

### 索引底层数据结构
* B+树，每层可以存储多个节点，数据存储在叶子节点，叶子节点相互之间双向链表连接
* 每次数据检索，非叶子节点上不存数据，可以增加每层存储的节点数量，降低树高，减少IO次数。
* 所有数据在叶子节点，所以对于所有数据的检索时间销量基本一致，比较稳定
* 叶子节点之间双向链表，便于区间查询。
* 相对于B树，数据存储与每个节点之上，每层存储的节点数降低，增加树高，增加IO次数，与每次IO数据量
* 相对于红黑树，红黑树每层只能存储两个节点，数据量大的时候，树很高，查询效率也大大降低。

### 什么是回表？
<img src="/images/index.png" />
* 聚集索引：叶子节点，存储整行数据。
* 二级索引：叶子节点，存储主键数据，然后再依据主键的通过聚集索引找到整行数据。
* 如果二级索引中索引字段没有我们要查询的字段数据，会拿到主键到聚集索引中继续查找，找到整行数据，这个过程就叫做回表。

### 覆盖索引？
* 使用了索引，并且查询的字段都在返回数据中，成为覆盖索引。
* 如果出现非覆盖索引，会出现回表操作，所以需要避免出现非覆盖索引。

### MYSQL 超大分页如何处理？
* 例如查询900000万条数据，limit 9000000,10 只要最后十条，这样sql语句会很慢，因为要对这些数据进行排序。
* 可以使用覆盖索引加子查询解决，使用主键id,进行覆盖索引查询，然后外面套上主查询，id=id即可。

### 什么时候索引会失效？
* 违法最左前缀法则，sql查询，对于联合索引，查询条件如果没有按照索引最左原则，会导致索引失效，业务中，name,status两个字段的联合索引，如果按照status字段查询，会导致索引失效
* 范围查询右边的列，不能使用索引
* 模糊匹配，like数据可能会导致索引失效
* 对于索引字段进行运算也会导致索引失效。
* 查询中出现类型转换会导致索引失效。

### sql优化
*  表设计：使用合适的字段类型，chat指定长度
*  查询：select 字段写明确，要多少返回多少，避免 * ，避免索引失效，
*  索引使用与建立： 在where，group by ,order by使用的字段上建立索引，避免出现非覆盖索引导致回表操作。

### undo log 和 redo log 区别？
<img src="/images/redolog.png" />

* redo log : 单页数据刷磁盘时，失败，通过redo log进行数据恢复，redo log 记录磁盘页数据的变化。
* undo log : 用户数据回滚，mvcc，记录的时数据逻辑日志，delete 时记录的时相反的insert语句，update时记录一条相反的update语句，数据回滚时，读取相应的undo log日志执行即可。
* redo log 保证事务的持久性，undo log 保证事务的原子性和一致性

### 事务的隔离性是如何保证的呢？
<img src="/images/mvcc.png">
<img src="/images/mvcc-1.png">

* 行锁，mvcc
* 行锁: 插入，更新操作，会对改行进行加锁操作，保证改行数据只能被一个线程修改成功。
* mvcc: 并发多版本控制：undo log + 隐藏字段 + read view 实现
* 隐藏字段: trx_id :记录每次操作的事务id,自增；roll_pointer: 指向上一个版本的事务记录地址
* read view: 解决一个事务，查询版本问题。规定一些规则
* *  依据read view 匹配规则和当前事务id判断该访问那个版本的数据。
* *  不同隔离级别产生read view 是不一样的。RC时，每次读都产生一个read view, RR时，只有第一次读才产生一个 read view
* undo log: 回滚日志：存储老版本数据，版本链：多个事务操作同一行数据，记录不同事务修改后的数据，通过roll_pointer 形成版本链。

### 