1. java中有哪些引用类型？ 
```test
强应用，软引用，弱引用，虚引用。强应用，GC不会删除。软引用，指向的对象，会在内存不足时被GC清除，弱引用：无论内存是否足够，遇到弱引用的对象，GC会清除。
虚引用：一种甚至无法找到对象的引用，用来标识对象已经被清除，加入引用队列。
```
2. 运行时数据区？
```test
  * 虚拟机栈：线程私有，由一个个栈帧构成，栈帧结构：局部变量表，操作数栈，动态连接，方法返回地址。主要存储临时变量，引用变量等局部变量
  * 堆区：存储对象实例数据。
  * 方法区：存放对象类信息，字段信息，方法信息，常量，静态变量
  * 程序计数器：用来记录程序执行的下一条指令位置，可以定位程序执行的位置，程序中断返回时快速恢复。
  * 本地方法栈：调用本地方法的时候使用的栈。
 注意：
   堆：<=1.7 的时候 划分为：年轻代，老年代，永久代 ，>=1.8 划分为 年轻代，老年代，元空间（变为直接内存）
   方法区：是一个概念，落地实现是，永久代和元空间，1.7之前，字符串常量池在永久代中--> 1.7将字符串常量池移到堆中--->1.8 永久代变为元空间
   为什么将字符串常量池移到堆中? 永久代，很少有GC,二字符串的创建存在大量失活对象，需要GC,所以移到到堆区。
 ```

3. 讲一下 Java 创建一个对象的过程 ?
```test
 * 类加载检测
    * 遇到New指令，检测指令的参数能否在常量池中找到类的符合引用，并检查该符号应用对应的对象是否被加载，连接，解析过。如果没有执行加载操作。
 * 分配内存  
    * 类在加载检测通过后，为对象在堆内分配内存，两种分配方式，指针碰撞，和空闲列表  
    * 指针碰撞：将用过的内存移到一段，未用的在另一端，中间使用指针标记，需要划分内存，移动指针即可（内存规整）  
    * 空闲列表：维护一个可以使用的内存块列表，分配是找一个足够的内存块分配。然后更新列表。（内存零散）  
 * 初始化零值
    * 将堆区分配的空间初始化0值，不包括对象头。
 * 设置对象头
    * 将对象的信息存储在对象头中，比如类信息，哈希码，对象代数，锁信息。
 ```
5. 指向init方法
```test
   * 执行<init>方法，为属性初始化赋值操作。
注意：对象存在线程安全问题，JVM如何解决的呢？
   * CAS+失败重试: 乐观锁，方式保证更新原子性操作
   * TLAB(Thread Local Allocation Buffer): 每个线程都有一个独享的堆内存空间（在Eden区），创建对象首先在TLAB中，如果对象大小大于TLAB采用方案1保证线程安全。
 ```
4. 如何回收方法区？
```
```
5. 垃圾回收算法？
```
  1. 标记清除：先标记存活对象，然后清除死亡的对象，存在大量内存碎片。
  2. 标记整理：先标记存活对象，然后将存活对象移到一段。解决了内存碎片问题。用在老年代，只有少数对象死亡，需要移到。
  3. 标记复制：将内存分为两块，分配使用一块，用完的时候标记，将存活的对象复制到另一块，然后清除这一块内存。在新生代使用，每次只有少数对象存活，复制少。
```
5. 垃圾回收器？ 
```
   1. Serial: 单线程垃圾回收器，进行垃圾回收时必须停掉其他所有线程。新生代使用 标记整理，老年代使用标记复制。 Serial old(Serial的老年代)
   2. ParNew: 多线程垃圾回收器，在Serial基础上变为多线程，可以多个线程一起回收，同样需要停掉其他线程
   3. parallel Scanvenge: 主要是为了提高cpu吞吐量，（cpu运行用于用户代码的时间与cpu总消耗时间比重）Parallel old:(老年代使用)
   4.CMS（Concurrent Mark Sweep）: 主要是为了减少停顿时间:
    * 初始标记: 暂停其他所有对象，标记与root直接相连的对象
    * 并发标记: GC与用户进程一起运行，第一次标记的对象继续往下标记
    * 并发预清理: GC与用于一起运行，标记由于并发产生的新对象
    * 重新标记: 暂停其他所有对象，标记由于并发未被标记但存活的对象。
    * 并发清除: 与应用进程一起开启，清除失活对象。
```
6. 新生代使用那些垃圾回收器，老年代使用那些垃圾回收器，各有什么特点？
```
```
7. 讲一下CMS垃圾回收器？
```
```

8. 类的生命周期？
```
```

9. 类的加载过程？
```
  将.calss文件加载到方法区，并在堆区生成一个Class对象。提供程序员访问方法区内数据结构的接口。 
  加载-->连接-->初始化
 * 加载： 
    1. 通过类的全限定名获取类定义的二进制字节 
    2. 将静态数据结构转化为方法区动态的数据结构 
    3. 在堆区生成一个代表该类的Class对象，作为方法区这些数据结构的访问接口。 
 * 连接： 
    1. 验证  
        * 字节码验证：是否符号java语法  
        * 元数据验证：语义分析，是否符合JAVA语法规范  
        * 文件格式验证：是否符合Class文件格式规范  
        * 符号引用验证：符合引用能否正确解析  
    2. 准备  
        * 为类的静态变量分配内存，初始化默认值。 
    3. 解析  
        * 将符号引用转为直接引用。 
 * 初始化：  
        * 执行<init>方法，初始化静态变量，静态代码块。
 最终在堆内生成一个大Class对象。    
 ```
 10. JVM类加载器有哪些？分别负责加载那些类？
 ```
 * BootStrap(根加载器)：加载JVM核心类库（rt.jar）
 * ExtClassLoader(扩展类加载器)：加载java.ext.dirs目录下面的类
 * AppClassLoader(系统类加载器)：从环境变量Classpath,和java.class.path路径加载文件
 * 用户自定义加载器：
 ```
 11. Java内存模型？
 ```
 * 指定不同线程如何以及何时查看其他线程写入共享变量的值，以及如何在必要时同步对共享变量的访问。
 * 主要内容: Java内存模型抽象结构，Happen-before原则，volatile关键字。
 * 抽象结构: 线程之间的共享变量存放在主内存，每个线程都有变量副本。
 * Happen-before: java支持指令重排（为了提高指令执行效率，缩短指令执行时间）但是会出现一些问题，happen-before不允许指令重排，前一个操作的结构对后后续的操作都是可见的。
 * volatile: 不允许指令重排，保证主存数据被更改后，其他线程缓存副本数据失效，需要从主存中重新加载。
 ```

 12. JVM内存模型？
 ```
 * 1.8之前，包括虚拟机栈，本地方法栈，堆，程序计数器，方法区（放在堆区，永久代）
 * 1.8最后，包括虚拟机栈，本地方法栈，堆，程序计数器，方法区（放在直接内存中，元空间）
 * 堆：主要存储实例对象，
 * 虚拟机栈：主要存储，局部变量，临时变量，引用变量
 * 方法区：存储常量，类信息
 * 本地方法栈：本地方法调用时使用，存储本地方法中使用的局部变量。
 * 程序计数器：用于记录指令执行的地址，方便上下文切换，知道程序执行到那个位置。
 ```
 
 13. 为什么用元空间代替永久代?
 ```test
 * 字符串放在方法区，频繁字符操作，会导致OOM,所以将永久代移到直接内存（对外内存）
 ```
 
 14. 永久代，元空间，方法区的关系？
 ```
 永久代是方法区的1.8之前的实现，元空间是方法区1.8之后的实现。
 ```

 15. Java对象的结构？
  ```
 * 对象包括，对象头（MarkWord,Class指针）,实例数据，填充字段
 * 对象头
      MarkWord: 存储锁，Hash,对象代数等信息
      Class指针: 指向大Class
 * 实例数据: 保存类的实例对象数据。
 * 填充字段: 按照8字节填充
 ```

### 如何定位cpu飙高问题？
```angular2html
1. 使用top 查看cpu占用最严重的进程id
2. 使用 ps H -eo pid,tid,%cpu | grep 进程id 查看当前进程中那个线程有问题
3. 使用 jstak 进程id, 查看线程详情，然后定位到上面找到的线程id 找到具体问题。
```
